[2015.9.11]

Looking at why recovering from xruns doesn't work when using MMAP.  Turns out snd_pcm_wait() takes a long time, but doesn't return an error.

snd_pcm_wait() took 0ms.
snd_pcm_wait() took 0ms.
snd_pcm_wait() took 0ms.
snd_pcm_wait() took 0ms.
snd_pcm_wait() took 3ms.
xrun
from snd_pcm_wait().
Committed.
snd_pcm_wait() took 0ms.
Committed.
snd_pcm_wait() took 1001ms.
Committed.
snd_pcm_wait() took 1001ms.
Committed.
snd_pcm_wait() took 1001ms.
Committed.
snd_pcm_wait() took 1001ms.
Committed.
snd_pcm_wait() took 1000ms.
Committed.
snd_pcm_wait() took 1001ms.
Committed.
snd_pcm_wait() took 1001ms.
Committed.
snd_pcm_wait() took 1000ms.
Committed.

So it's timing out.

A simple "started = false" in got_xrun(), so we call snd_pcm_start() after sending the next buffer, fixes it.

The timing code:
SFX struct timespec start_time, end_time;
SFX err = clock_gettime(CLOCK_MONOTONIC, &start_time);
SFX if (err < 0) log("clock_gettime() returned %d.", err);
   err = snd_pcm_wait(playback, 1000);
SFX clock_gettime(CLOCK_MONOTONIC, &end_time);
SFX long ms = (end_time.tv_nsec - start_time.tv_nsec) / 1000000 + (end_time.tv_sec - start_time.tv_sec) * 1000;
SFX log("snd_pcm_wait() took %dms.", ms);

On the ONE, 45 seems to be the minimum buffer size to prevent xrun death.  For the built-in interface, it's 48.


[2015.9.15]

Since adding capture, it can get into a state where it has a continuous flurry of xruns.  Capture's snd_pcm_wait() call doesn't seem to be the culprit... nor mmap_{begin,commit}.  Nor the mmaps on the playback side.  Interestingly, *all* xruns, flurry or no, seem to be preceded by "!capture_is_ready".  No, not on the next run.  Next run, sometimes it does and sometimes it doesn't, it did for the flurry.  But all xruns I'm seeing come from snd_pcm_wait().  Neither snd_pcm_wait() seems to take inordinately long.  It is the send-buffers part of the engine that takes longest during a flurry (dominated by snd_pcm_recover()), but not longer than a non-flurry xrun.

